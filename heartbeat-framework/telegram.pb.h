// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: telegram.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_telegram_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_telegram_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_telegram_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_telegram_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_telegram_2eproto;
class DataCollection;
class DataCollectionDefaultTypeInternal;
extern DataCollectionDefaultTypeInternal _DataCollection_default_instance_;
class ManualSwitch;
class ManualSwitchDefaultTypeInternal;
extern ManualSwitchDefaultTypeInternal _ManualSwitch_default_instance_;
class ServerStatusDatas;
class ServerStatusDatasDefaultTypeInternal;
extern ServerStatusDatasDefaultTypeInternal _ServerStatusDatas_default_instance_;
class Telegram;
class TelegramDefaultTypeInternal;
extern TelegramDefaultTypeInternal _Telegram_default_instance_;
class TransActionData;
class TransActionDataDefaultTypeInternal;
extern TransActionDataDefaultTypeInternal _TransActionData_default_instance_;
class TransData;
class TransDataDefaultTypeInternal;
extern TransDataDefaultTypeInternal _TransData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::DataCollection* Arena::CreateMaybeMessage<::DataCollection>(Arena*);
template<> ::ManualSwitch* Arena::CreateMaybeMessage<::ManualSwitch>(Arena*);
template<> ::ServerStatusDatas* Arena::CreateMaybeMessage<::ServerStatusDatas>(Arena*);
template<> ::Telegram* Arena::CreateMaybeMessage<::Telegram>(Arena*);
template<> ::TransActionData* Arena::CreateMaybeMessage<::TransActionData>(Arena*);
template<> ::TransData* Arena::CreateMaybeMessage<::TransData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TransType : int {
  HEARTBEAT = 0,
  ACTION = 1,
  GET_SERVER_STATUS = 2,
  GET_DATA = 3,
  REPLY_ACTION = 4,
  REPLY_SERVER_STATUS = 5,
  REPLY_DATA = 6,
  TransType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransType_IsValid(int value);
constexpr TransType TransType_MIN = HEARTBEAT;
constexpr TransType TransType_MAX = REPLY_DATA;
constexpr int TransType_ARRAYSIZE = TransType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransType_descriptor();
template<typename T>
inline const std::string& TransType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransType_descriptor(), enum_t_value);
}
inline bool TransType_Parse(
    const std::string& name, TransType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransType>(
    TransType_descriptor(), name, value);
}
enum ActionType : int {
  GET_RES = 0,
  GOT_RES = 1,
  FREE_RES = 2,
  FREED_RES = 3,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = GET_RES;
constexpr ActionType ActionType_MAX = FREED_RES;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor();
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionType_descriptor(), enum_t_value);
}
inline bool ActionType_Parse(
    const std::string& name, ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
// ===================================================================

class TransActionData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TransActionData) */ {
 public:
  inline TransActionData() : TransActionData(nullptr) {};
  virtual ~TransActionData();

  TransActionData(const TransActionData& from);
  TransActionData(TransActionData&& from) noexcept
    : TransActionData() {
    *this = ::std::move(from);
  }

  inline TransActionData& operator=(const TransActionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransActionData& operator=(TransActionData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransActionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransActionData* internal_default_instance() {
    return reinterpret_cast<const TransActionData*>(
               &_TransActionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransActionData& a, TransActionData& b) {
    a.Swap(&b);
  }
  inline void Swap(TransActionData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransActionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransActionData* New() const final {
    return CreateMaybeMessage<TransActionData>(nullptr);
  }

  TransActionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransActionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransActionData& from);
  void MergeFrom(const TransActionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransActionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TransActionData";
  }
  protected:
  explicit TransActionData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_telegram_2eproto);
    return ::descriptor_table_telegram_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // .ActionType type = 1;
  void clear_type();
  ::ActionType type() const;
  void set_type(::ActionType value);
  private:
  ::ActionType _internal_type() const;
  void _internal_set_type(::ActionType value);
  public:

  // bool result = 2;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TransActionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_telegram_2eproto;
};
// -------------------------------------------------------------------

class ServerStatusDatas PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerStatusDatas) */ {
 public:
  inline ServerStatusDatas() : ServerStatusDatas(nullptr) {};
  virtual ~ServerStatusDatas();

  ServerStatusDatas(const ServerStatusDatas& from);
  ServerStatusDatas(ServerStatusDatas&& from) noexcept
    : ServerStatusDatas() {
    *this = ::std::move(from);
  }

  inline ServerStatusDatas& operator=(const ServerStatusDatas& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerStatusDatas& operator=(ServerStatusDatas&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerStatusDatas& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerStatusDatas* internal_default_instance() {
    return reinterpret_cast<const ServerStatusDatas*>(
               &_ServerStatusDatas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServerStatusDatas& a, ServerStatusDatas& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerStatusDatas* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerStatusDatas* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerStatusDatas* New() const final {
    return CreateMaybeMessage<ServerStatusDatas>(nullptr);
  }

  ServerStatusDatas* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerStatusDatas>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerStatusDatas& from);
  void MergeFrom(const ServerStatusDatas& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStatusDatas* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerStatusDatas";
  }
  protected:
  explicit ServerStatusDatas(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_telegram_2eproto);
    return ::descriptor_table_telegram_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerStatusFieldNumber = 1,
    kHaveVirtualIpFieldNumber = 2,
  };
  // bool server_status = 1;
  void clear_server_status();
  bool server_status() const;
  void set_server_status(bool value);
  private:
  bool _internal_server_status() const;
  void _internal_set_server_status(bool value);
  public:

  // bool have_virtual_ip = 2;
  void clear_have_virtual_ip();
  bool have_virtual_ip() const;
  void set_have_virtual_ip(bool value);
  private:
  bool _internal_have_virtual_ip() const;
  void _internal_set_have_virtual_ip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerStatusDatas)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool server_status_;
  bool have_virtual_ip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_telegram_2eproto;
};
// -------------------------------------------------------------------

class DataCollection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataCollection) */ {
 public:
  inline DataCollection() : DataCollection(nullptr) {};
  virtual ~DataCollection();

  DataCollection(const DataCollection& from);
  DataCollection(DataCollection&& from) noexcept
    : DataCollection() {
    *this = ::std::move(from);
  }

  inline DataCollection& operator=(const DataCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataCollection& operator=(DataCollection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataCollection* internal_default_instance() {
    return reinterpret_cast<const DataCollection*>(
               &_DataCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DataCollection& a, DataCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(DataCollection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataCollection* New() const final {
    return CreateMaybeMessage<DataCollection>(nullptr);
  }

  DataCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataCollection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataCollection& from);
  void MergeFrom(const DataCollection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataCollection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataCollection";
  }
  protected:
  explicit DataCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_telegram_2eproto);
    return ::descriptor_table_telegram_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // string data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 size = 1;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:DataCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_telegram_2eproto;
};
// -------------------------------------------------------------------

class ManualSwitch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ManualSwitch) */ {
 public:
  inline ManualSwitch() : ManualSwitch(nullptr) {};
  virtual ~ManualSwitch();

  ManualSwitch(const ManualSwitch& from);
  ManualSwitch(ManualSwitch&& from) noexcept
    : ManualSwitch() {
    *this = ::std::move(from);
  }

  inline ManualSwitch& operator=(const ManualSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManualSwitch& operator=(ManualSwitch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ManualSwitch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ManualSwitch* internal_default_instance() {
    return reinterpret_cast<const ManualSwitch*>(
               &_ManualSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ManualSwitch& a, ManualSwitch& b) {
    a.Swap(&b);
  }
  inline void Swap(ManualSwitch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManualSwitch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ManualSwitch* New() const final {
    return CreateMaybeMessage<ManualSwitch>(nullptr);
  }

  ManualSwitch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ManualSwitch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ManualSwitch& from);
  void MergeFrom(const ManualSwitch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManualSwitch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ManualSwitch";
  }
  protected:
  explicit ManualSwitch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_telegram_2eproto);
    return ::descriptor_table_telegram_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToggleFieldNumber = 1,
    kTakeOrReleaseFieldNumber = 2,
  };
  // bool toggle = 1;
  void clear_toggle();
  bool toggle() const;
  void set_toggle(bool value);
  private:
  bool _internal_toggle() const;
  void _internal_set_toggle(bool value);
  public:

  // int32 take_or_release = 2;
  void clear_take_or_release();
  ::PROTOBUF_NAMESPACE_ID::int32 take_or_release() const;
  void set_take_or_release(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_take_or_release() const;
  void _internal_set_take_or_release(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ManualSwitch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool toggle_;
  ::PROTOBUF_NAMESPACE_ID::int32 take_or_release_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_telegram_2eproto;
};
// -------------------------------------------------------------------

class TransData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TransData) */ {
 public:
  inline TransData() : TransData(nullptr) {};
  virtual ~TransData();

  TransData(const TransData& from);
  TransData(TransData&& from) noexcept
    : TransData() {
    *this = ::std::move(from);
  }

  inline TransData& operator=(const TransData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransData& operator=(TransData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransData& default_instance();

  enum DataOneofCase {
    kTransActionData = 3,
    kServerStatusDatas = 4,
    kDataCollection = 5,
    DATA_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransData* internal_default_instance() {
    return reinterpret_cast<const TransData*>(
               &_TransData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TransData& a, TransData& b) {
    a.Swap(&b);
  }
  inline void Swap(TransData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransData* New() const final {
    return CreateMaybeMessage<TransData>(nullptr);
  }

  TransData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransData& from);
  void MergeFrom(const TransData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TransData";
  }
  protected:
  explicit TransData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_telegram_2eproto);
    return ::descriptor_table_telegram_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManualSwitchFieldNumber = 6,
    kTypeFieldNumber = 1,
    kSizeFieldNumber = 2,
    kTransActionDataFieldNumber = 3,
    kServerStatusDatasFieldNumber = 4,
    kDataCollectionFieldNumber = 5,
  };
  // .ManualSwitch manual_switch = 6;
  bool has_manual_switch() const;
  private:
  bool _internal_has_manual_switch() const;
  public:
  void clear_manual_switch();
  const ::ManualSwitch& manual_switch() const;
  ::ManualSwitch* release_manual_switch();
  ::ManualSwitch* mutable_manual_switch();
  void set_allocated_manual_switch(::ManualSwitch* manual_switch);
  private:
  const ::ManualSwitch& _internal_manual_switch() const;
  ::ManualSwitch* _internal_mutable_manual_switch();
  public:
  void unsafe_arena_set_allocated_manual_switch(
      ::ManualSwitch* manual_switch);
  ::ManualSwitch* unsafe_arena_release_manual_switch();

  // .TransType type = 1;
  void clear_type();
  ::TransType type() const;
  void set_type(::TransType value);
  private:
  ::TransType _internal_type() const;
  void _internal_set_type(::TransType value);
  public:

  // int32 size = 2;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .TransActionData trans_action_data = 3;
  bool has_trans_action_data() const;
  private:
  bool _internal_has_trans_action_data() const;
  public:
  void clear_trans_action_data();
  const ::TransActionData& trans_action_data() const;
  ::TransActionData* release_trans_action_data();
  ::TransActionData* mutable_trans_action_data();
  void set_allocated_trans_action_data(::TransActionData* trans_action_data);
  private:
  const ::TransActionData& _internal_trans_action_data() const;
  ::TransActionData* _internal_mutable_trans_action_data();
  public:
  void unsafe_arena_set_allocated_trans_action_data(
      ::TransActionData* trans_action_data);
  ::TransActionData* unsafe_arena_release_trans_action_data();

  // .ServerStatusDatas server_status_datas = 4;
  bool has_server_status_datas() const;
  private:
  bool _internal_has_server_status_datas() const;
  public:
  void clear_server_status_datas();
  const ::ServerStatusDatas& server_status_datas() const;
  ::ServerStatusDatas* release_server_status_datas();
  ::ServerStatusDatas* mutable_server_status_datas();
  void set_allocated_server_status_datas(::ServerStatusDatas* server_status_datas);
  private:
  const ::ServerStatusDatas& _internal_server_status_datas() const;
  ::ServerStatusDatas* _internal_mutable_server_status_datas();
  public:
  void unsafe_arena_set_allocated_server_status_datas(
      ::ServerStatusDatas* server_status_datas);
  ::ServerStatusDatas* unsafe_arena_release_server_status_datas();

  // .DataCollection data_collection = 5;
  bool has_data_collection() const;
  private:
  bool _internal_has_data_collection() const;
  public:
  void clear_data_collection();
  const ::DataCollection& data_collection() const;
  ::DataCollection* release_data_collection();
  ::DataCollection* mutable_data_collection();
  void set_allocated_data_collection(::DataCollection* data_collection);
  private:
  const ::DataCollection& _internal_data_collection() const;
  ::DataCollection* _internal_mutable_data_collection();
  public:
  void unsafe_arena_set_allocated_data_collection(
      ::DataCollection* data_collection);
  ::DataCollection* unsafe_arena_release_data_collection();

  void clear_data_oneof();
  DataOneofCase data_oneof_case() const;
  // @@protoc_insertion_point(class_scope:TransData)
 private:
  class _Internal;
  void set_has_trans_action_data();
  void set_has_server_status_datas();
  void set_has_data_collection();

  inline bool has_data_oneof() const;
  inline void clear_has_data_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ManualSwitch* manual_switch_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  union DataOneofUnion {
    DataOneofUnion() {}
    ::TransActionData* trans_action_data_;
    ::ServerStatusDatas* server_status_datas_;
    ::DataCollection* data_collection_;
  } data_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_telegram_2eproto;
};
// -------------------------------------------------------------------

class Telegram PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Telegram) */ {
 public:
  inline Telegram() : Telegram(nullptr) {};
  virtual ~Telegram();

  Telegram(const Telegram& from);
  Telegram(Telegram&& from) noexcept
    : Telegram() {
    *this = ::std::move(from);
  }

  inline Telegram& operator=(const Telegram& from) {
    CopyFrom(from);
    return *this;
  }
  inline Telegram& operator=(Telegram&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Telegram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Telegram* internal_default_instance() {
    return reinterpret_cast<const Telegram*>(
               &_Telegram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Telegram& a, Telegram& b) {
    a.Swap(&b);
  }
  inline void Swap(Telegram* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Telegram* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Telegram* New() const final {
    return CreateMaybeMessage<Telegram>(nullptr);
  }

  Telegram* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Telegram>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Telegram& from);
  void MergeFrom(const Telegram& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Telegram* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Telegram";
  }
  protected:
  explicit Telegram(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_telegram_2eproto);
    return ::descriptor_table_telegram_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .TransData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::TransData& data() const;
  ::TransData* release_data();
  ::TransData* mutable_data();
  void set_allocated_data(::TransData* data);
  private:
  const ::TransData& _internal_data() const;
  ::TransData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::TransData* data);
  ::TransData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:Telegram)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::TransData* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_telegram_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransActionData

// .ActionType type = 1;
inline void TransActionData::clear_type() {
  type_ = 0;
}
inline ::ActionType TransActionData::_internal_type() const {
  return static_cast< ::ActionType >(type_);
}
inline ::ActionType TransActionData::type() const {
  // @@protoc_insertion_point(field_get:TransActionData.type)
  return _internal_type();
}
inline void TransActionData::_internal_set_type(::ActionType value) {
  
  type_ = value;
}
inline void TransActionData::set_type(::ActionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TransActionData.type)
}

// bool result = 2;
inline void TransActionData::clear_result() {
  result_ = false;
}
inline bool TransActionData::_internal_result() const {
  return result_;
}
inline bool TransActionData::result() const {
  // @@protoc_insertion_point(field_get:TransActionData.result)
  return _internal_result();
}
inline void TransActionData::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void TransActionData::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:TransActionData.result)
}

// -------------------------------------------------------------------

// ServerStatusDatas

// bool server_status = 1;
inline void ServerStatusDatas::clear_server_status() {
  server_status_ = false;
}
inline bool ServerStatusDatas::_internal_server_status() const {
  return server_status_;
}
inline bool ServerStatusDatas::server_status() const {
  // @@protoc_insertion_point(field_get:ServerStatusDatas.server_status)
  return _internal_server_status();
}
inline void ServerStatusDatas::_internal_set_server_status(bool value) {
  
  server_status_ = value;
}
inline void ServerStatusDatas::set_server_status(bool value) {
  _internal_set_server_status(value);
  // @@protoc_insertion_point(field_set:ServerStatusDatas.server_status)
}

// bool have_virtual_ip = 2;
inline void ServerStatusDatas::clear_have_virtual_ip() {
  have_virtual_ip_ = false;
}
inline bool ServerStatusDatas::_internal_have_virtual_ip() const {
  return have_virtual_ip_;
}
inline bool ServerStatusDatas::have_virtual_ip() const {
  // @@protoc_insertion_point(field_get:ServerStatusDatas.have_virtual_ip)
  return _internal_have_virtual_ip();
}
inline void ServerStatusDatas::_internal_set_have_virtual_ip(bool value) {
  
  have_virtual_ip_ = value;
}
inline void ServerStatusDatas::set_have_virtual_ip(bool value) {
  _internal_set_have_virtual_ip(value);
  // @@protoc_insertion_point(field_set:ServerStatusDatas.have_virtual_ip)
}

// -------------------------------------------------------------------

// DataCollection

// int32 size = 1;
inline void DataCollection::clear_size() {
  size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataCollection::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataCollection::size() const {
  // @@protoc_insertion_point(field_get:DataCollection.size)
  return _internal_size();
}
inline void DataCollection::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  size_ = value;
}
inline void DataCollection::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:DataCollection.size)
}

// string data = 2;
inline void DataCollection::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DataCollection::data() const {
  // @@protoc_insertion_point(field_get:DataCollection.data)
  return _internal_data();
}
inline void DataCollection::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:DataCollection.data)
}
inline std::string* DataCollection::mutable_data() {
  // @@protoc_insertion_point(field_mutable:DataCollection.data)
  return _internal_mutable_data();
}
inline const std::string& DataCollection::_internal_data() const {
  return data_.Get();
}
inline void DataCollection::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DataCollection::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:DataCollection.data)
}
inline void DataCollection::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:DataCollection.data)
}
inline void DataCollection::set_data(const char* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:DataCollection.data)
}
inline std::string* DataCollection::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DataCollection::release_data() {
  // @@protoc_insertion_point(field_release:DataCollection.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataCollection::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:DataCollection.data)
}
inline std::string* DataCollection::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataCollection.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DataCollection::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataCollection.data)
}

// -------------------------------------------------------------------

// ManualSwitch

// bool toggle = 1;
inline void ManualSwitch::clear_toggle() {
  toggle_ = false;
}
inline bool ManualSwitch::_internal_toggle() const {
  return toggle_;
}
inline bool ManualSwitch::toggle() const {
  // @@protoc_insertion_point(field_get:ManualSwitch.toggle)
  return _internal_toggle();
}
inline void ManualSwitch::_internal_set_toggle(bool value) {
  
  toggle_ = value;
}
inline void ManualSwitch::set_toggle(bool value) {
  _internal_set_toggle(value);
  // @@protoc_insertion_point(field_set:ManualSwitch.toggle)
}

// int32 take_or_release = 2;
inline void ManualSwitch::clear_take_or_release() {
  take_or_release_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ManualSwitch::_internal_take_or_release() const {
  return take_or_release_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ManualSwitch::take_or_release() const {
  // @@protoc_insertion_point(field_get:ManualSwitch.take_or_release)
  return _internal_take_or_release();
}
inline void ManualSwitch::_internal_set_take_or_release(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  take_or_release_ = value;
}
inline void ManualSwitch::set_take_or_release(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_take_or_release(value);
  // @@protoc_insertion_point(field_set:ManualSwitch.take_or_release)
}

// -------------------------------------------------------------------

// TransData

// .TransType type = 1;
inline void TransData::clear_type() {
  type_ = 0;
}
inline ::TransType TransData::_internal_type() const {
  return static_cast< ::TransType >(type_);
}
inline ::TransType TransData::type() const {
  // @@protoc_insertion_point(field_get:TransData.type)
  return _internal_type();
}
inline void TransData::_internal_set_type(::TransType value) {
  
  type_ = value;
}
inline void TransData::set_type(::TransType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TransData.type)
}

// int32 size = 2;
inline void TransData::clear_size() {
  size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransData::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransData::size() const {
  // @@protoc_insertion_point(field_get:TransData.size)
  return _internal_size();
}
inline void TransData::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  size_ = value;
}
inline void TransData::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:TransData.size)
}

// .TransActionData trans_action_data = 3;
inline bool TransData::_internal_has_trans_action_data() const {
  return data_oneof_case() == kTransActionData;
}
inline bool TransData::has_trans_action_data() const {
  return _internal_has_trans_action_data();
}
inline void TransData::set_has_trans_action_data() {
  _oneof_case_[0] = kTransActionData;
}
inline void TransData::clear_trans_action_data() {
  if (_internal_has_trans_action_data()) {
    if (GetArena() == nullptr) {
      delete data_oneof_.trans_action_data_;
    }
    clear_has_data_oneof();
  }
}
inline ::TransActionData* TransData::release_trans_action_data() {
  // @@protoc_insertion_point(field_release:TransData.trans_action_data)
  if (_internal_has_trans_action_data()) {
    clear_has_data_oneof();
      ::TransActionData* temp = data_oneof_.trans_action_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_oneof_.trans_action_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TransActionData& TransData::_internal_trans_action_data() const {
  return _internal_has_trans_action_data()
      ? *data_oneof_.trans_action_data_
      : *reinterpret_cast< ::TransActionData*>(&::_TransActionData_default_instance_);
}
inline const ::TransActionData& TransData::trans_action_data() const {
  // @@protoc_insertion_point(field_get:TransData.trans_action_data)
  return _internal_trans_action_data();
}
inline ::TransActionData* TransData::unsafe_arena_release_trans_action_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TransData.trans_action_data)
  if (_internal_has_trans_action_data()) {
    clear_has_data_oneof();
    ::TransActionData* temp = data_oneof_.trans_action_data_;
    data_oneof_.trans_action_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransData::unsafe_arena_set_allocated_trans_action_data(::TransActionData* trans_action_data) {
  clear_data_oneof();
  if (trans_action_data) {
    set_has_trans_action_data();
    data_oneof_.trans_action_data_ = trans_action_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TransData.trans_action_data)
}
inline ::TransActionData* TransData::_internal_mutable_trans_action_data() {
  if (!_internal_has_trans_action_data()) {
    clear_data_oneof();
    set_has_trans_action_data();
    data_oneof_.trans_action_data_ = CreateMaybeMessage< ::TransActionData >(GetArena());
  }
  return data_oneof_.trans_action_data_;
}
inline ::TransActionData* TransData::mutable_trans_action_data() {
  // @@protoc_insertion_point(field_mutable:TransData.trans_action_data)
  return _internal_mutable_trans_action_data();
}

// .ServerStatusDatas server_status_datas = 4;
inline bool TransData::_internal_has_server_status_datas() const {
  return data_oneof_case() == kServerStatusDatas;
}
inline bool TransData::has_server_status_datas() const {
  return _internal_has_server_status_datas();
}
inline void TransData::set_has_server_status_datas() {
  _oneof_case_[0] = kServerStatusDatas;
}
inline void TransData::clear_server_status_datas() {
  if (_internal_has_server_status_datas()) {
    if (GetArena() == nullptr) {
      delete data_oneof_.server_status_datas_;
    }
    clear_has_data_oneof();
  }
}
inline ::ServerStatusDatas* TransData::release_server_status_datas() {
  // @@protoc_insertion_point(field_release:TransData.server_status_datas)
  if (_internal_has_server_status_datas()) {
    clear_has_data_oneof();
      ::ServerStatusDatas* temp = data_oneof_.server_status_datas_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_oneof_.server_status_datas_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ServerStatusDatas& TransData::_internal_server_status_datas() const {
  return _internal_has_server_status_datas()
      ? *data_oneof_.server_status_datas_
      : *reinterpret_cast< ::ServerStatusDatas*>(&::_ServerStatusDatas_default_instance_);
}
inline const ::ServerStatusDatas& TransData::server_status_datas() const {
  // @@protoc_insertion_point(field_get:TransData.server_status_datas)
  return _internal_server_status_datas();
}
inline ::ServerStatusDatas* TransData::unsafe_arena_release_server_status_datas() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TransData.server_status_datas)
  if (_internal_has_server_status_datas()) {
    clear_has_data_oneof();
    ::ServerStatusDatas* temp = data_oneof_.server_status_datas_;
    data_oneof_.server_status_datas_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransData::unsafe_arena_set_allocated_server_status_datas(::ServerStatusDatas* server_status_datas) {
  clear_data_oneof();
  if (server_status_datas) {
    set_has_server_status_datas();
    data_oneof_.server_status_datas_ = server_status_datas;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TransData.server_status_datas)
}
inline ::ServerStatusDatas* TransData::_internal_mutable_server_status_datas() {
  if (!_internal_has_server_status_datas()) {
    clear_data_oneof();
    set_has_server_status_datas();
    data_oneof_.server_status_datas_ = CreateMaybeMessage< ::ServerStatusDatas >(GetArena());
  }
  return data_oneof_.server_status_datas_;
}
inline ::ServerStatusDatas* TransData::mutable_server_status_datas() {
  // @@protoc_insertion_point(field_mutable:TransData.server_status_datas)
  return _internal_mutable_server_status_datas();
}

// .DataCollection data_collection = 5;
inline bool TransData::_internal_has_data_collection() const {
  return data_oneof_case() == kDataCollection;
}
inline bool TransData::has_data_collection() const {
  return _internal_has_data_collection();
}
inline void TransData::set_has_data_collection() {
  _oneof_case_[0] = kDataCollection;
}
inline void TransData::clear_data_collection() {
  if (_internal_has_data_collection()) {
    if (GetArena() == nullptr) {
      delete data_oneof_.data_collection_;
    }
    clear_has_data_oneof();
  }
}
inline ::DataCollection* TransData::release_data_collection() {
  // @@protoc_insertion_point(field_release:TransData.data_collection)
  if (_internal_has_data_collection()) {
    clear_has_data_oneof();
      ::DataCollection* temp = data_oneof_.data_collection_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_oneof_.data_collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DataCollection& TransData::_internal_data_collection() const {
  return _internal_has_data_collection()
      ? *data_oneof_.data_collection_
      : *reinterpret_cast< ::DataCollection*>(&::_DataCollection_default_instance_);
}
inline const ::DataCollection& TransData::data_collection() const {
  // @@protoc_insertion_point(field_get:TransData.data_collection)
  return _internal_data_collection();
}
inline ::DataCollection* TransData::unsafe_arena_release_data_collection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TransData.data_collection)
  if (_internal_has_data_collection()) {
    clear_has_data_oneof();
    ::DataCollection* temp = data_oneof_.data_collection_;
    data_oneof_.data_collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransData::unsafe_arena_set_allocated_data_collection(::DataCollection* data_collection) {
  clear_data_oneof();
  if (data_collection) {
    set_has_data_collection();
    data_oneof_.data_collection_ = data_collection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TransData.data_collection)
}
inline ::DataCollection* TransData::_internal_mutable_data_collection() {
  if (!_internal_has_data_collection()) {
    clear_data_oneof();
    set_has_data_collection();
    data_oneof_.data_collection_ = CreateMaybeMessage< ::DataCollection >(GetArena());
  }
  return data_oneof_.data_collection_;
}
inline ::DataCollection* TransData::mutable_data_collection() {
  // @@protoc_insertion_point(field_mutable:TransData.data_collection)
  return _internal_mutable_data_collection();
}

// .ManualSwitch manual_switch = 6;
inline bool TransData::_internal_has_manual_switch() const {
  return this != internal_default_instance() && manual_switch_ != nullptr;
}
inline bool TransData::has_manual_switch() const {
  return _internal_has_manual_switch();
}
inline void TransData::clear_manual_switch() {
  if (GetArena() == nullptr && manual_switch_ != nullptr) {
    delete manual_switch_;
  }
  manual_switch_ = nullptr;
}
inline const ::ManualSwitch& TransData::_internal_manual_switch() const {
  const ::ManualSwitch* p = manual_switch_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ManualSwitch*>(
      &::_ManualSwitch_default_instance_);
}
inline const ::ManualSwitch& TransData::manual_switch() const {
  // @@protoc_insertion_point(field_get:TransData.manual_switch)
  return _internal_manual_switch();
}
inline void TransData::unsafe_arena_set_allocated_manual_switch(
    ::ManualSwitch* manual_switch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(manual_switch_);
  }
  manual_switch_ = manual_switch;
  if (manual_switch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TransData.manual_switch)
}
inline ::ManualSwitch* TransData::release_manual_switch() {
  auto temp = unsafe_arena_release_manual_switch();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ManualSwitch* TransData::unsafe_arena_release_manual_switch() {
  // @@protoc_insertion_point(field_release:TransData.manual_switch)
  
  ::ManualSwitch* temp = manual_switch_;
  manual_switch_ = nullptr;
  return temp;
}
inline ::ManualSwitch* TransData::_internal_mutable_manual_switch() {
  
  if (manual_switch_ == nullptr) {
    auto* p = CreateMaybeMessage<::ManualSwitch>(GetArena());
    manual_switch_ = p;
  }
  return manual_switch_;
}
inline ::ManualSwitch* TransData::mutable_manual_switch() {
  // @@protoc_insertion_point(field_mutable:TransData.manual_switch)
  return _internal_mutable_manual_switch();
}
inline void TransData::set_allocated_manual_switch(::ManualSwitch* manual_switch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete manual_switch_;
  }
  if (manual_switch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(manual_switch);
    if (message_arena != submessage_arena) {
      manual_switch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manual_switch, submessage_arena);
    }
    
  } else {
    
  }
  manual_switch_ = manual_switch;
  // @@protoc_insertion_point(field_set_allocated:TransData.manual_switch)
}

inline bool TransData::has_data_oneof() const {
  return data_oneof_case() != DATA_ONEOF_NOT_SET;
}
inline void TransData::clear_has_data_oneof() {
  _oneof_case_[0] = DATA_ONEOF_NOT_SET;
}
inline TransData::DataOneofCase TransData::data_oneof_case() const {
  return TransData::DataOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Telegram

// string version = 1;
inline void Telegram::clear_version() {
  version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Telegram::version() const {
  // @@protoc_insertion_point(field_get:Telegram.version)
  return _internal_version();
}
inline void Telegram::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Telegram.version)
}
inline std::string* Telegram::mutable_version() {
  // @@protoc_insertion_point(field_mutable:Telegram.version)
  return _internal_mutable_version();
}
inline const std::string& Telegram::_internal_version() const {
  return version_.Get();
}
inline void Telegram::_internal_set_version(const std::string& value) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Telegram::set_version(std::string&& value) {
  
  version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:Telegram.version)
}
inline void Telegram::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:Telegram.version)
}
inline void Telegram::set_version(const char* value,
    size_t size) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:Telegram.version)
}
inline std::string* Telegram::_internal_mutable_version() {
  
  return version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Telegram::release_version() {
  // @@protoc_insertion_point(field_release:Telegram.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Telegram::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:Telegram.version)
}
inline std::string* Telegram::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Telegram.version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return version_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Telegram::unsafe_arena_set_allocated_version(
    std::string* version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (version != nullptr) {
    
  } else {
    
  }
  version_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Telegram.version)
}

// .TransData data = 2;
inline bool Telegram::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool Telegram::has_data() const {
  return _internal_has_data();
}
inline void Telegram::clear_data() {
  if (GetArena() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::TransData& Telegram::_internal_data() const {
  const ::TransData* p = data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::TransData*>(
      &::_TransData_default_instance_);
}
inline const ::TransData& Telegram::data() const {
  // @@protoc_insertion_point(field_get:Telegram.data)
  return _internal_data();
}
inline void Telegram::unsafe_arena_set_allocated_data(
    ::TransData* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Telegram.data)
}
inline ::TransData* Telegram::release_data() {
  auto temp = unsafe_arena_release_data();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TransData* Telegram::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:Telegram.data)
  
  ::TransData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::TransData* Telegram::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TransData>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::TransData* Telegram::mutable_data() {
  // @@protoc_insertion_point(field_mutable:Telegram.data)
  return _internal_mutable_data();
}
inline void Telegram::set_allocated_data(::TransData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Telegram.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TransType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TransType>() {
  return ::TransType_descriptor();
}
template <> struct is_proto_enum< ::ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionType>() {
  return ::ActionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_telegram_2eproto
